# Introduction

The `smithy4rs` project provides [Smithy](smithy.io) code generators for clients, server, 
and shapes for the [Rust](https://rust-lang.org/) programming language.

Generated code supports [protocol-agnostic](#what-does-it-mean-to-be-protocol-agnostic) clients, 
servers, and event systems via 
[schema-guided (de)serialization](#what-is-schema-guided-deserialization).

```admonish info
`smithy4rs` is an _unofficial_, _community-supported_ Smithy code generator for Rust. 

If you are looking for the official code generators used to create the 
the AWS Rust SDK, head over to [`smithy-rs`](https://github.com/smithy-lang/smithy-rs).
```

### Core components

The `smithy4rs` project contains three core types of components: 
1. `smithy-build` plugins - used to integrate with the smithy toolchain and generate
   code from a Smithy model.
2. Core libraries - provide the core functionality for generated Rust code.
3. Protocol implementations - libraries that implement (de)serialization and 
   binding logic that can be used to interface between clients and servers.

```admonish warning title="Early Access"
All interfaces of code generators, core libraries, and protocol implementations are
unstable and may be subject to change without notice or guaranteed of backwards-compatibility.
```

## Getting Started

For a guided introduction to this project, see the [Quick Start](quick-start.md) guide.

For a more in-depth exploration, check out our [Tutorials](tutorials/README.md).

---
## FAQ
### What is different between `smithy4rs` and the official code generators?

`smithy4rs` was built specifically to provide a number of features
we felt were missing from the official Rust code generators:

1. **serde compatibility** - `smithy4rs` allows users to optionally (de)serialize shapes
   using the rust `serde` ecosystem. See [serde-compatibility](guides/serde-compatibility.md) for more info on how to
   enable this feature.
2. **Type codegen** - `smithy4rs` allows users to generate standalone types _without_ need for a client
   or service. This makes the development of more flexible middleware possible for clients and servers
   and even opens up the possibility of generating event types.
3. **Protocol-agnostic codegen** - The shapes, clients, and servers generated by `smithy4rs` are fully
   protocol-agnostic. In contrast, `smithy-rs` generates protocol-specific (de)serialization code.
4. **Dynamic schemas** - `smithy4rs` is designed to allow users to dynamically load and use schemas for
   (de)serialization. This can be used to support fully dynamic clients and server-mocks.
5. **"Any"-ish Document support** - [`smithy-java`](https://github.com/smithy-lang/smithy-java) introduced
   a concept of documents as an `Any` type for the Smithy data model. `smithy4rs` provides first
   class support for this new Document model.

### What does it mean to be "protocol agnostic"?
A "protocol" is composed of both the transport (i.e. HTTP or MQTT) 
and serialization format (i.e. JSON or XML) used to communicate data between
clients and servers.

Data representions in the Smithy IDL are not tied to any specific wire format or transport.
In contrast to IDL's like `protobuf` (`gRPC`), this allows Smithy servers and clients to 
support any protocol they would like, even swapping out client protocols at runtime.

This ability to be "agnostic" to the final wire format and transport is what is meant 
when we say Smithy is "protocol-agnostic".

TODO: NOTE on benefits of protocol agnosticism?

### What is Schema-guided (de)serialization?

TODO



